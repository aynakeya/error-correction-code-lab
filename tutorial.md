# Error correction code ECC 纠错

那么传数据的时候错了怎么办呢？现实里比特翻转是常态：电磁干扰、存储介质老化、无线信道衰落，都会让 0 变 1，1 变 0。一个直觉的解决办法是“错了就重传”，但很多场景没法等或者不能重传，比如直播、卫星链路、存储介质。于是就有了纠错码。

前向纠错（FEC, Forward Error Correction）：发送者在传输前使用纠错码（ECC）对数据编码，主动加入冗余；接收者用冗余信息来恢复原始数据。一般来说，解码得到的是“最有可能”的原始数据。

下面我会按“从简单到复杂”的顺序，把这个 demo 里的每个标签页都讲一遍。讲解中我会明确写出「操作」，你可以边演示边讲。整段按 30 分钟节奏设计：每个部分都有停顿、互动、总结。

# FEC

FEC 的核心是：发送端主动添加冗余，接收端利用冗余信息自我纠错。我们先从最基础的方案开始。

## FEC 重复码（约 5 分钟）

这是一个非常 trivial 的方案：把每个 bit 重复发 n 次。比如 n=3：

0 -> 000
1 -> 111

接收方用“多数表决”解码：

- 如果收到 101，多数是 1，就判 1。
- 如果收到 001，多数是 0，就判 0。

优点：好理解、好实现。缺点也很直接：

- 效率极低：码率是 1/n，n=3 只有 1/3 的有效信息。
- 容错有限：只要翻转超过一半，就会解码错。

**操作**
1) 切到「重复码」标签页。  
2) 输入一串短一点的比特，比如 `101101`。  
3) 把重复次数设为 3（默认就是 3）。  
4) 在“接收端”区域点击一个比特翻转。  

**讲解点**
- 你会看到“多数表决解码”的结果。翻转 1 个时通常还能纠回。  
- 如果你连续翻转同一组里的 2 个，比特就会判错。  
- 这告诉我们：冗余可以提升可靠性，但代价是带宽（1/3 码率）。  

**小互动**
“大家猜一下，重复 5 次是不是一定更好？”  
答：更抗错，但带宽更差，代价更高。

## FEC 分组码 Block codes（过渡，约 2 分钟）

分组码会把数据切成固定长度的块。一个 (n,k) 分组码表示：

- k 位原始数据
- 添加 r = n-k 位冗余
- 总长度 n 位

例如 (7,4) 汉明码、(4,3) 奇偶校验码。分组码的优势是“结构明确、容易并行”，也是硬件实现的基础。  
接下来我们从最小的分组码：奇偶校验开始。

### FEC 奇偶校验 Parity（约 5 分钟）

奇偶校验是最简单的分组码：只加 1 位校验位。

- 偶校验：数据位 + 校验位中 1 的总数为偶数
- 奇校验：数据位 + 校验位中 1 的总数为奇数

举个例子（数据 101）：

校验类型    规则                     示例
偶校验      1 的总数为偶             1010（2 个 1）
奇校验      1 的总数为奇             1011（3 个 1）

**操作**
1) 切到「奇偶校验」标签页。  
2) 输入 `1101001`（默认值也可以）。  
3) 指着“奇偶校验计算”，强调最后会附加一个 P 位。  
4) 在“接收端”区域翻转任意 1 位。  

**讲解点**
- 状态会变成“失败（检测到错误）”，说明它能检错。  

**继续操作**
5) 再翻转另一个位（保证总共翻转 2 位）。  

**讲解点**
- 状态会显示“通过”，但其实我们知道有错。  
- 结论：奇偶校验“只能检错，不能纠错，也不能定位”。  

为什么奇偶校验可以用 XOR 来算？因为 XOR 等价于“模 2 加法”，最终结果就是 1 的个数 mod 2：

0 xor 0 = 0
0 xor 1 = 1
1 xor 0 = 1
1 xor 1 = 0

所以“把所有 bit XOR 起来”的结果，就告诉我们 1 的个数是偶还是奇。这个结论会贯穿整个汉明码。

（应用：RAID 阵列里常见的 parity block，就是用 XOR 来重建单块丢失的数据。）

**RAID parity 例子（详细解释）**

假设我们有 3 个数据盘 + 1 个校验盘（RAID5 思想）。每一“条带”里三块数据，校验盘存的是三块数据逐位 XOR 的结果：

数据盘 A：1010101010  
数据盘 B：1011001010  
数据盘 C：0000000001  
校验盘 P：A ⊕ B ⊕ C

我们来按位 XOR：

```
   1010101010
⊕  1011001010
⊕  0000000001
=  0001100001
```

所以校验盘 P 是 `0001100001`。  
如果某天数据盘 B 坏了，你还有 A、C 和 P，那么：

```
B = P ⊕ A ⊕ C
```

把剩下的三块 XOR 一遍，就能把 B 恢复出来。  
这就是 parity 的意义：**不是纠正每一位的错，而是“允许丢一整块盘”，还能重建数据**。

注意：RAID5 只能抗 1 块盘损坏；如果坏两块，就无法恢复。这和“奇偶校验能检错但不能纠错”的限制本质是一样的：冗余提供的“信息量”有限。

### FEC 汉明码 Hamming Code（约 8 分钟）

奇偶校验只能说“有错”，不能说“错在哪”。汉明码解决的是“定位出错位置”，从而实现单比特纠错。

先看个直觉的故事：把 1~7 号位置放在三个“重叠区域”里，每个区域用一个校验位判断对错。哪个区域报错，就能反推出具体位置。这其实就是汉明码的思路。

汉明码有两个关键规则：

- 校验位放在 2 的幂位置：1、2、4、8...
- 每个校验位负责一组位置：比如 P1 覆盖所有“二进制最低位为 1”的位置，P2 覆盖第二位为 1 的位置，以此类推。

这样每个位置都能用“校验位的组合”唯一标识。解码时我们重新算一遍校验，得到一组 syndrome（伴随式）：

- syndrome = 0：没错
- syndrome ≠ 0：它的二进制值就是错误位置

在 demo 的“汉明码”页你能看到这件事直观地发生：

**操作**
1) 切到「汉明码」标签页。  
2) 输入 `1011`，数据位大小保持 4。  
3) 指着布局说明：P1、P2、P4 这些是校验位。  
4) 指着“校验位计算”的 XOR 过程，强调“偶校验 + XOR”。  
5) 在编码网格上 hover 一个校验位，演示它覆盖了哪些位置。  
6) 在“接收端”网格中翻转第 5 位（或任意一位）。  

**讲解点**
- 下方 syndrome 会变化，二进制值的十进制就是错误位置。  
- 这意味着我们不仅能“发现错”，还知道“错在哪”。  
- 所以标准汉明码可以纠 1 位错误。  

**继续操作**
7) 再翻转第二位（制造双错）。  

**讲解点**
- 系统会提示可能多位错误。  
- 汉明码能检出“可能有错”，但不能保证纠正正确。  

标准汉明码的能力：纠 1 位、检 2 位（检测到错误，但不保证定位正确）。

## 汉明 + 总体奇偶校验（SEC-DED）（约 4 分钟）

汉明码如果翻转两位，会产生一个“看起来像单错”的 syndrome，导致修错方向错。为了避免这个问题，我们再加一个“总体奇偶校验位”P0，得到 SEC-DED（Single Error Correction, Double Error Detection）。

它的判决逻辑很经典，四种情况：

1) syndrome = 0 且总体校验通过：无错  
2) syndrome ≠ 0 且总体校验失败：单错，可纠  
3) syndrome = 0 且总体校验失败：P0 自己错了  
4) syndrome ≠ 0 且总体校验通过：双错，能检但不能纠

**操作**
1) 切到「SEC-DED」标签页。  
2) 先不翻转，指出“总体校验 P0”。  
3) 翻转 1 位，观察状态：可纠正。  
4) 再翻转第二位，观察状态：双错检测。  
5) 只翻转 P0，看提示“总体校验错误”。  

**讲解点**
- SEC-DED 能“纠 1 位、检 2 位”。  
- 这就是 ECC 内存常用的方案，比如 (72,64)。  

那如果错了 3 位怎么办？答案通常不是“更复杂的码”，而是“降低错误发生率”。纠错码只是系统可靠性的一部分。

## 卷积码 Convolutional Codes（约 6 分钟）

到现在我们讲的都是“分组码”。卷积码的思路不一样：它不是按块处理，而是把输入 bit 按时间流过一个移位寄存器，连续输出编码比特。你可以把它想成“带记忆的编码器”。

在 demo 的“卷积码”页，核心概念有三个：

1) **编码器结构**：一个长度为 v 的寄存器（记忆） + 一组生成多项式（taps）。  
2) **码率**：k/n，这里我们演示的是 k=1 的情况，每输入 1 个 bit，输出 n 个 bit。  
3) **约束长度**：K = v + 1，决定了“当前输出受多少历史输入影响”。  

我们用一组简单参数讲清楚它的“工作方式”：  
n=2、k=1、v=2，生成多项式是 111 和 101。  
- 111 表示“输入位 + 两个寄存器位”都参与 XOR。  
- 101 表示“输入位 + 第 2 个寄存器位”参与 XOR。  

所以每一步都会输出两位：  
v1 = 输入 ⊕ R1 ⊕ R2  
v2 = 输入 ⊕ R2  

这里的 R1、R2 就是寄存器里的历史输入。

操作步骤是这样的：

- 输入序列按位推进，寄存器每次右移。  
- 每个输出位由 taps 选中的比特 XOR 得出。  
- 最后会补上 v 个 0 把寄存器“冲洗”回 0 状态（flush bits）。  

**操作**
1) 切到「卷积码」标签页。  
2) 输入 `11011`，保持 n=2、k=1、v=2（默认值）。  
3) 指出生成多项式 taps（比如 111、101）。  
4) 点击 Next，讲寄存器如何移位，如何 XOR 得到输出。  
5) 点 Auto 让它自动跑 2~3 步，再点 Pause。  

**讲解点**
- 输出比特依赖历史输入，所以叫“卷积”。  
- 码率是 1/2：每输入 1 位输出 2 位。  
- v 越大，记忆越长，抗噪能力更强，但解码复杂度也更高。  
- 最后补 0 是为了让寄存器回到全 0，方便译码路径收敛。  

**小例子（口算示意）**
假设寄存器初始为 00，输入序列是 1：  
R1=0, R2=0  
v1 = 1⊕0⊕0 = 1  
v2 = 1⊕0 = 1  
输出就是 11。  
下一步寄存器右移，R1=1, R2=0，再输入 1，就会得到不同的输出。  
这就是“输出依赖历史”的直观体现。  

**手算完整序列 + 解码示例（可边写边点）**
我们用 demo 的默认参数：n=2, k=1, v=2，生成多项式 111 和 101。  
输入序列选 `11011`，寄存器初始 `00`，末尾补两个 0 进行冲洗。  

编码过程（逐步）：

```
步  输入  寄存器(R1R2)  v1=输入⊕R1⊕R2  v2=输入⊕R2  输出
1   1     00            1              1            11
2   1     10            0              1            01
3   0     11            0              1            01
4   1     01            0              0            00
5   1     10            0              1            01
6   0     11            0              1            01
7   0     01            1              1            11
```

所以编码序列（发送）是：  
`11 01 01 00 01 01 11` → 连起来是 `11010100010111`。

**操作**
1) 在“编码仿真控制”点 Next，核对每一步输出是否一致。  
2) 在“编码输出（点击翻转）”里，把第 3 个输出对 `01` 翻成 `11`，再把倒数第二个 `01` 翻成 `00`（制造 2 处错误）。  
   这样接收序列变成：`11 01 11 00 01 00 11`。  

**解码思路（口头解释）**
- 维特比不是“逐步修”，而是“全局找最短路径”。  
- 每一步把接收到的 2 位和“所有可能输出”比汉明距离，累加度量。  
- 每个状态只保留代价最小的幸存路径。  
- 最后得到“最可能”的输入序列。  

**操作**
3) 在 Viterbi 区域点 Next，观察每一步的度量和幸存路径。  
4) 最后你会看到解码输出回到原始 `11011`（如果错误不太多）。  

这段例子里，“错误存在但能恢复”的感觉，会让同学理解为什么卷积码 + 维特比在通信系统里非常常用。  

### 维特比译码 Viterbi（约 5 分钟）

卷积码的解码是另一个难点：它不是“单独一个块”能决定的，而是要在“所有可能的路径”中找到最合理的那条。

维特比算法做的事情是：

- 把所有状态画成一个网格（trellis）。
- 对每一步输入，计算每条路径的“分支度量”（这里用汉明距离）。
- 对每个状态只保留代价最小的那条路径（幸存路径）。

**操作**
1) 在“编码输出（点击翻转）”里翻转 1~2 个比特，制造噪声。  
2) 在 Viterbi 区域点击 Next，观察每一步的度量。  
3) 看“幸存路径”，强调只有代价最小的路径会保留。  

**讲解点**
- 这是“最大似然解码”：不是绝对正确，而是最可能正确。  

**维特比度量逐步计算（具体数值）**
下面把上面的接收序列 `11 01 11 00 01 00 11` 做完整度量计算。  
状态用寄存器 `R1R2` 表示（00, 01, 10, 11），输出是 2 位。  

转移表（输入 -> 下一状态 / 输出）：

```
00: 0->00/00, 1->10/11
01: 0->00/11, 1->10/00
10: 0->01/10, 1->11/01
11: 0->01/01, 1->11/10
```

度量规则：每步的分支度量 = 该步输出与接收符号的汉明距离。  
累积度量 = 上一步状态度量 + 分支度量。  

初始：t0 时刻只有状态 00 的度量为 0，其余为 ∞。  

```
t1 收到 11
00: 2 (00,0)   01: inf   10: 0 (00,1)   11: inf

t2 收到 01
00: 3 (00,0)   01: 2 (10,0)   10: 3 (00,1)   11: 0 (10,1)

t3 收到 11
00: 2 (01,0)   01: 1 (11,0)   10: 3 (00,1)   11: 1 (11,1)

t4 收到 00
00: 2 (00,0)   01: 2 (11,0)   10: 1 (01,1)   11: 2 (11,1)

t5 收到 01
00: 3 (00,0)   01: 2 (11,0)   10: 3 (00,1)   11: 1 (10,1)

t6 收到 00
00: 3 (00,0)   01: 2 (11,0)   10: 2 (01,1)   11: 2 (11,1)

t7 收到 11
00: 2 (01,0)   01: 3 (10,0)   10: 3 (00,1)   11: 3 (10,1)
```

括号里是“最佳前驱状态 + 输入比特”。  
最后一步最小度量是状态 00 的 2，所以从 00 回溯：

```
t7 00 <- (01,0)
t6 01 <- (11,0)
t5 11 <- (10,1)
t4 10 <- (01,1)
t3 01 <- (11,0)
t2 11 <- (10,1)
t1 10 <- (00,1)
```

得到输入序列：`1 1 0 1 1 0 0`，去掉尾部 v=2 的冲洗位后是 `11011`，成功恢复原始数据。  

这也解释了一个关键观念：纠错码的解码往往不是“绝对正确”，而是“最大似然”。
