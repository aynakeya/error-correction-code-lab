# Error correction code ECC 纠错


那么传数据的时候错了怎么办呢。


前向纠错（FEC）Forward Error correction：发送者在传输前使用纠错码（ECC）对数据进行编码。额外信息（信息冗余）由代码添加以供接收者用来恢复原始数据。一般来说，重建的数据被认为是“最有可能”的原始数据。

我们先来讲FEC向前纠错

# FEC

FEC的核心是发送端主动添加冗余，接收端利用冗余信息自我纠错。我们先从最基础的方案开始。

## FEC 重复码

这是一个非常trivial的解决方案，即重传每个bits，

比如我们需要传一个1bit数据

0 -> 000, 001, 010, 100
1 -> 111, 110,

接收方采用“多数表决”解码：

效率极低：仅传输1比特有效信息需3倍带宽
容错有限：若两比特同时出错（如 111→101），会错误判为 0

当然你也可以重复几位，那么他抗干扰能力会更强，但是。

## FEC 分组码 Block codes

分组码将数据切分为固定长度的块。一个 (n,k) 分组码 表示：

k 位原始数据

添加 r = n-k 位冗余

总长度 n 位

比如 (7,4) 汉明码 (4,3) 奇偶校验码

### FEC 奇偶校验 Parity

分为偶校验和奇校验

偶校验，就是查看所有bit，然后检查bit为1的个数，如果是偶数校验位就为0
如果是奇校验，那么如果是奇数校验位为0


同时我们也可以这么理解，如果是偶校验，那么bit中1的个数，包括校验位的个数为偶数，如果数据位的个数为奇数，那么校验位为1补上来让总数变成偶数，
如果是奇校验，那么1的个数为奇数，如果数据位1的个数为偶数，那么校验位会补一个1来变成奇数。

校验类型    规则  示例（数据 101）
偶校验 数据位+校验位中 1 的总数为偶    1010 (共2个1)
奇校验 数据位+校验位中 1 的总数为奇    1011 (共3个1)


ok那么我们来看一下例子把

假如你有一个数

0101010100111 1 偶校验
0101010100110 1  发现1的个数为奇数，错误，重传

那么如果纠错码，错了了

0101010100110 0 发现还是一样的，可以发现有错，

所以纠错码在保护其他数据的同时，也保护了自己。


但是我们发现，假如一个数据中有两个bit发生了偏转，那么我们就无法发现。

不能纠错，能纠错、我们知道哪一个出错了



检测，我们可以对每个bit做xor，如果是偶校验，查看最后的值是不是0，如果是奇校验，查看最后的值是不是1。


比如。

奇偶校验之所以能用异或（XOR）运算，处理二进制数的最低位时，能直接改变其奇偶性。 然后我们判断是一个数是否是奇偶也只需要看最低位就OK了。

01010111 0+1+0+1+0+1+1+1 = 5 5是奇数

再来看看xor表
0 xor 0  = 0
0 xor 1 =  1
1 xor 0 = 1
1 xor 1 = 0


简单来说，是因为如果我们观察这个表，我么可以发现xor相当于在做最低位least significant bit的加法，0+0=0 0+1=1 1+0=0 1+1=10=0。 所以xor得到的值就是1个数的最低位的值。
因为异或的本质是模2加法, 最终结果恰等于1的总数模2的值（0表偶数个1，1表奇数个1）

应用

如果我们知道哪一个坏了，我们就可以恢复

Parity data is used by RAID arrays (redundant array of independent/inexpensive disks)

1010101010
1011001010
0000000001

1000000000


### FEC 汉明

https://harryli0088.github.io/hamming-code/

#### 标准汉明

主要解决的就是找到出错位在哪个地方

RGB

我们先来看一个简单的例子，红区黄区蓝区，一只哈吉米在绿区，也在蓝区，但不在红区。请问这只哈吉米在1234567哪个区域。

其实这个例子就是汉明码的简单示例，是否在某个区域就是校验码是否正确，中间的四个重叠区域就是被校验码保护的四个信息位bit，123就是校验位

我们把信息位分为三组3个为一组，然后分别用一个校验位来对这三个信息位做奇偶校验，这里我们是用偶校验。比如1校验456 2校验567 3校验457

假如某个发生了偏转，我们可以很容易的通过检查校验码发现这个哪一个出错了。

001
010
100

011
101
110
111

检测两位，纠正一位

为什么汉明码会非常常用呢，因为他的硬件实现比较简单

这就是为什么前面用了偶校验的原因，我们只需要对每一组的bit做xor运算，最后得到的位数就是他的地址。最简单的一集。

(15,11)汉明码

如果汉明翻转了两位，我们发现，能检测出错误，但是位置错了。为了预防这种东西的出现，我们可以另外加一个bit，即sec-dec来规避这种情况情况

#### 汉明+奇偶 SEC-DEC single error correcting-double error detection code

添加全局奇偶校验位（P0

应用在计算机内存中常用，即ecc内存，常见的比如 (72,64) sec-dec

应用：计算机ECC内存广泛采用 (72,64) SEC-DED码（每64位数据+8位校验，可抗单比特纠错+双比特检错）。

大家说，啊啊啊，啊啊啊啊如果有3个错了怎么办呢，这个时候与其找到更好的 错误纠正，不如保证错误不出现。



## 卷积码 convolutional codes.
